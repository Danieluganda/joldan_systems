/**\n * RFQ Service\n * \n * RFQ-specific business logic\n * Feature 3: RFQ creation and management\n */\n\nconst RFQ = require('../db/models/RFQ');\nconst Submission = require('../db/models/Submission');\nconst Evaluation = require('../db/models/Evaluation');\nconst logger = require('../utils/logger');\n\nclass RFQService {\n  /**\n   * Publish RFQ and notify vendors\n   */\n  static async publishRFQ(rfqId) {\n    try {\n      const rfq = await RFQ.update(rfqId, {\n        status: 'published',\n        publish_date: new Date(),\n      });\n      logger.info('RFQ published', { rfqId });\n      // TODO: Send notifications to registered vendors\n      return rfq;\n    } catch (error) {\n      logger.error('Error publishing RFQ', { error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Close RFQ and prevent new submissions\n   */\n  static async closeRFQ(rfqId) {\n    try {\n      const rfq = await RFQ.update(rfqId, {\n        status: 'closed',\n      });\n      logger.info('RFQ closed', { rfqId });\n      return rfq;\n    } catch (error) {\n      logger.error('Error closing RFQ', { error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Get submission statistics for RFQ\n   */\n  static async getSubmissionStats(rfqId) {\n    try {\n      const submissions = await Submission.getByRFQ(rfqId);\n      const stats = {\n        rfqId,\n        totalSubmissions: submissions.length,\n        submissionsByStatus: this._groupByStatus(submissions),\n        priceRange: this._calculatePriceRange(submissions),\n        vendorCount: new Set(submissions.map((s) => s.vendor_id)).size,\n      };\n      return stats;\n    } catch (error) {\n      logger.error('Error getting submission stats', { error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Consolidate evaluation scores\n   */\n  static async consolidateEvaluations(rfqId) {\n    try {\n      const submissions = await Submission.getByRFQ(rfqId);\n      const consolidatedScores = [];\n\n      for (const submission of submissions) {\n        const evaluations = await Evaluation.getBySubmission(submission.id);\n        const avgTechnical =\n          evaluations.length > 0\n            ? evaluations.reduce((sum, e) => sum + (e.technical_score || 0), 0) /\n              evaluations.length\n            : 0;\n        const avgFinancial =\n          evaluations.length > 0\n            ? evaluations.reduce((sum, e) => sum + (e.financial_score || 0), 0) /\n              evaluations.length\n            : 0;\n        const overallScore = avgTechnical * 0.6 + avgFinancial * 0.4;\n\n        consolidatedScores.push({\n          submissionId: submission.id,\n          vendorId: submission.vendor_id,\n          technicalScore: Math.round(avgTechnical * 100) / 100,\n          financialScore: Math.round(avgFinancial * 100) / 100,\n          overallScore: Math.round(overallScore * 100) / 100,\n          evaluationCount: evaluations.length,\n        });\n      }\n\n      // Sort by overall score descending\n      consolidatedScores.sort((a, b) => b.overallScore - a.overallScore);\n\n      logger.info('Evaluations consolidated', { rfqId, submissionCount: submissions.length });\n      return consolidatedScores;\n    } catch (error) {\n      logger.error('Error consolidating evaluations', { error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Get ranked submissions\n   */\n  static async getRankedSubmissions(rfqId) {\n    try {\n      const consolidatedScores = await this.consolidateEvaluations(rfqId);\n      return consolidatedScores;\n    } catch (error) {\n      logger.error('Error getting ranked submissions', { error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Validate RFQ closure\n   */\n  static async validateRFQClosure(rfqId) {\n    try {\n      const submissions = await Submission.getByRFQ(rfqId);\n      if (submissions.length === 0) {\n        return { valid: false, message: 'No submissions received' };\n      }\n\n      return { valid: true, submissionCount: submissions.length };\n    } catch (error) {\n      logger.error('Error validating RFQ closure', { error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Helper: Group submissions by status\n   */\n  static _groupByStatus(submissions) {\n    return submissions.reduce((groups, sub) => {\n      groups[sub.status] = (groups[sub.status] || 0) + 1;\n      return groups;\n    }, {});\n  }\n\n  /**\n   * Helper: Calculate price range\n   */\n  static _calculatePriceRange(submissions) {\n    const prices = submissions\n      .map((s) => parseFloat(s.quoted_price))\n      .filter((p) => !isNaN(p));\n\n    if (prices.length === 0) {\n      return { min: 0, max: 0, avg: 0 };\n    }\n\n    return {\n      min: Math.min(...prices),\n      max: Math.max(...prices),\n      avg: prices.reduce((a, b) => a + b, 0) / prices.length,\n    };\n  }\n}\n\nmodule.exports = RFQService;\n"
