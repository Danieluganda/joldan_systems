/**\n * Storage Service\n * \n * Application layer for file storage operations\n * Feature 10: Document management\n */\n\nconst StorageManager = require('../config/storage');\nconst logger = require('../utils/logger');\nconst crypto = require('crypto');\n\nclass StorageService {\n  constructor() {\n    this.storage = new StorageManager();\n  }\n\n  /**\n   * Upload file to storage\n   */\n  async uploadFile(file, options = {}) {\n    try {\n      const fileHash = crypto\n        .createHash('sha256')\n        .update(file.buffer || file.data)\n        .digest('hex');\n\n      const result = await this.storage.uploadFile(\n        file,\n        options.path || `uploads/${Date.now()}`\n      );\n\n      logger.info('File uploaded', {\n        fileName: file.originalname || file.name,\n        size: file.size,\n        hash: fileHash,\n      });\n\n      return {\n        success: true,\n        url: result.url,\n        fileHash,\n        size: file.size,\n        uploadedAt: new Date(),\n      };\n    } catch (error) {\n      logger.error('Error uploading file', { error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Delete file from storage\n   */\n  async deleteFile(filePath) {\n    try {\n      await this.storage.deleteFile(filePath);\n      logger.info('File deleted', { filePath });\n      return { success: true };\n    } catch (error) {\n      logger.error('Error deleting file', { error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Get file from storage\n   */\n  async getFile(filePath) {\n    try {\n      const file = await this.storage.getFile(filePath);\n      return file;\n    } catch (error) {\n      logger.error('Error getting file', { error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Upload document for entity\n   */\n  async uploadDocument(entityType, entityId, file, metadata = {}) {\n    try {\n      const path = `documents/${entityType}/${entityId}/${Date.now()}-${file.originalname}`;\n      const result = await this.uploadFile(file, { path });\n\n      return {\n        ...result,\n        entityType,\n        entityId,\n        fileName: file.originalname,\n        mimeType: file.mimetype,\n        metadata,\n      };\n    } catch (error) {\n      logger.error('Error uploading document', { error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Delete multiple files\n   */\n  async deleteFiles(filePaths) {\n    try {\n      const results = await Promise.all(filePaths.map((path) => this.deleteFile(path)));\n      logger.info('Multiple files deleted', { count: filePaths.length });\n      return { success: true, deletedCount: results.length };\n    } catch (error) {\n      logger.error('Error deleting multiple files', { error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Verify file integrity\n   */\n  async verifyFileIntegrity(filePath, expectedHash) {\n    try {\n      const file = await this.getFile(filePath);\n      const actualHash = crypto\n        .createHash('sha256')\n        .update(file)\n        .digest('hex');\n\n      return {\n        valid: actualHash === expectedHash,\n        expectedHash,\n        actualHash,\n      };\n    } catch (error) {\n      logger.error('Error verifying file integrity', { error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Get storage usage statistics\n   */\n  async getStorageStats() {\n    return {\n      provider: this.storage.provider,\n      timestamp: new Date(),\n      // Additional stats based on provider\n    };\n  }\n}\n\nmodule.exports = new StorageService();\n"
