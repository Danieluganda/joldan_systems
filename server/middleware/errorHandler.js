/**\n * Error Handler Middleware\n * \n * Global error handling and response formatting\n */\n\nconst logger = require('../utils/logger');\n\nclass AppError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.statusCode = statusCode;\n  }\n}\n\n/**\n * Global error handling middleware\n */\nconst errorHandler = (err, req, res, next) => {\n  err.statusCode = err.statusCode || 500;\n  err.message = err.message || 'Internal Server Error';\n\n  // Log the error\n  logger.error(`${err.statusCode} - ${err.message}`, {\n    stack: err.stack,\n    url: req.originalUrl,\n    method: req.method,\n    userId: req.user?.id,\n  });\n\n  // Mongoose validation error\n  if (err.name === 'ValidationError') {\n    const message = Object.values(err.errors).map((e) => e.message);\n    return res.status(400).json({\n      success: false,\n      message: 'Validation Error',\n      errors: message,\n    });\n  }\n\n  // Mongoose duplicate key error\n  if (err.code === 11000) {\n    const field = Object.keys(err.keyValue)[0];\n    return res.status(400).json({\n      success: false,\n      message: `${field} already exists`,\n    });\n  }\n\n  // JWT errors\n  if (err.name === 'JsonWebTokenError') {\n    return res.status(401).json({\n      success: false,\n      message: 'Invalid token',\n    });\n  }\n\n  if (err.name === 'TokenExpiredError') {\n    return res.status(401).json({\n      success: false,\n      message: 'Token expired',\n    });\n  }\n\n  // Custom app error\n  res.status(err.statusCode).json({\n    success: false,\n    message: err.message,\n    ...(process.env.NODE_ENV === 'development' && { stack: err.stack }),\n  });\n};\n\n/**\n * Async handler wrapper\n */\nconst asyncHandler = (fn) => (req, res, next) => {\n  Promise.resolve(fn(req, res, next)).catch(next);\n};\n\nmodule.exports = {\n  AppError,\n  errorHandler,\n  asyncHandler,\n};\n"
